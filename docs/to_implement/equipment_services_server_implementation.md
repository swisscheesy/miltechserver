# Equipment Services Server Implementation Design

## Executive Summary

This document provides a detailed implementation design for the Equipment Services API on the Go server, based on the mobile application's API specification document. The implementation follows the established codebase patterns and architecture to provide seamless integration with the existing shop system.

## Architecture Overview

### Current Codebase Analysis

The server follows a clean layered architecture:

- **Framework**: Gin web framework with RESTful endpoints
- **ORM**: Go-Jet for type-safe PostgreSQL database operations
- **Authentication**: Firebase Auth with JWT token validation
- **Architecture Pattern**: Repository-Service-Controller pattern
- **Database**: PostgreSQL with UUID primary keys
- **Error Handling**: Structured logging with slog and standardized error responses

### Existing Shop System Integration

The equipment services will integrate with these existing entities:
- **Shops**: Main container for all shop-related data
- **ShopVehicle**: Equipment/vehicle entities that services will track
- **ShopLists**: Lists that services can reference
- **ShopMembers**: User authorization and permissions
- **Users**: Authentication and user identification

## Database Schema Design

### New Table: equipment_services

Based on the existing pattern analysis and mobile requirements:

```sql
CREATE TABLE equipment_services (
    id VARCHAR(36) PRIMARY KEY,                    -- UUID, consistent with existing pattern
    shop_id VARCHAR(36) NOT NULL,                  -- Foreign key to shops.id
    equipment_id VARCHAR(36) NOT NULL,             -- Foreign key to shop_vehicle.id
    list_id VARCHAR(36) NOT NULL,                  -- Foreign key to shop_lists.id
    description TEXT NOT NULL,                     -- Service description (1-500 chars)
    service_type TEXT NOT NULL,                    -- Service type (free-form text)
    created_by VARCHAR(36) NOT NULL,              -- User ID who created service
    is_completed BOOLEAN NOT NULL DEFAULT FALSE,  -- Track completed vs scheduled services
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    service_date TIMESTAMP NULL,                   -- Scheduled/completed service date
    service_hours INTEGER NULL,                    -- Equipment hours/mileage at service (non-negative)
    
    -- Foreign key constraints with CASCADE DELETE (following existing pattern)
    CONSTRAINT fk_equipment_services_shop 
        FOREIGN KEY (shop_id) REFERENCES shops(id) ON DELETE CASCADE,
    CONSTRAINT fk_equipment_services_equipment 
        FOREIGN KEY (equipment_id) REFERENCES shop_vehicle(id) ON DELETE CASCADE,
    CONSTRAINT fk_equipment_services_list 
        FOREIGN KEY (list_id) REFERENCES shop_lists(id) ON DELETE CASCADE,
    
    -- Validation constraints
    CONSTRAINT chk_service_hours_non_negative 
        CHECK (service_hours IS NULL OR service_hours >= 0),
    
    -- Indexes for performance (following existing patterns)
    INDEX idx_equipment_services_shop_id (shop_id),
    INDEX idx_equipment_services_equipment_id (equipment_id),
    INDEX idx_equipment_services_service_date (service_date),
    INDEX idx_equipment_services_created_by (created_by),
    INDEX idx_equipment_services_service_type (service_type),
    INDEX idx_equipment_services_is_completed (is_completed),
    
    -- Composite indexes for common query patterns
    INDEX idx_equipment_services_shop_date (shop_id, service_date),
    INDEX idx_equipment_services_equipment_date (equipment_id, service_date),
    INDEX idx_equipment_services_shop_completed (shop_id, is_completed)
);
```

### Data Model Go Struct (Generated)

This will be generated by go-jet but will look like:

```go
type EquipmentServices struct {
    ID           string     `sql:"primary_key" json:"id"`
    ShopID       string     `json:"shop_id"`
    EquipmentID  string     `json:"equipment_id"`
    ListID       string     `json:"list_id"`
    Description  string     `json:"description"`
    ServiceType  string     `json:"service_type"`
    CreatedBy    string     `json:"created_by"`
    IsCompleted  bool       `json:"is_completed"`
    CreatedAt    time.Time  `json:"created_at"`
    UpdatedAt    time.Time  `json:"updated_at"`
    ServiceDate  *time.Time `json:"service_date"`
    ServiceHours *int32     `json:"service_hours"`
}
```

## Implementation Components

### 1. Request/Response Models

#### Request Models (`api/request/equipment_services_request.go`)

```go
type CreateEquipmentServiceRequest struct {
    EquipmentID  string     `json:"equipment_id" binding:"required"`
    ListID       string     `json:"list_id" binding:"required"`
    Description  string     `json:"description" binding:"required,min=1,max=500"`
    ServiceType  string     `json:"service_type" binding:"required"`
    IsCompleted  bool       `json:"is_completed"`
    ServiceDate  *time.Time `json:"service_date"`
    ServiceHours *int32     `json:"service_hours" binding:"omitempty,min=0"`
}

type UpdateEquipmentServiceRequest struct {
    ServiceID    string     `json:"service_id" binding:"required"`
    Description  string     `json:"description" binding:"required,min=1,max=500"`
    ServiceType  string     `json:"service_type" binding:"required"`
    IsCompleted  bool       `json:"is_completed"`
    ServiceDate  *time.Time `json:"service_date"`
    ServiceHours *int32     `json:"service_hours" binding:"omitempty,min=0"`
}

type GetEquipmentServicesRequest struct {
    EquipmentID *string `form:"equipment_id"`
    StartDate   *string `form:"start_date"`    // ISO 8601 format
    EndDate     *string `form:"end_date"`      // ISO 8601 format
    ServiceType *string `form:"service_type"`  // Free-form service type filter
    IsCompleted *bool   `form:"is_completed"`  // Filter by completion status
    Status      *string `form:"status"`        // overdue, due_soon, scheduled, completed
    Limit       int     `form:"limit,default=100" binding:"omitempty,min=1,max=500"`
    Offset      int     `form:"offset,default=0" binding:"omitempty,min=0"`
}

type GetCalendarServicesRequest struct {
    StartDate   string  `form:"start_date" binding:"required"`  // ISO 8601 format
    EndDate     string  `form:"end_date" binding:"required"`    // ISO 8601 format  
    EquipmentID *string `form:"equipment_id"`
}

type GetDueSoonServicesRequest struct {
    DaysAhead   int     `form:"days_ahead,default=7" binding:"omitempty,min=1,max=30"`
    EquipmentID *string `form:"equipment_id"`
    Limit       int     `form:"limit,default=50" binding:"omitempty,min=1,max=200"`
}
```

#### Response Models (`api/response/equipment_services_response.go`)

```go
type EquipmentServiceResponse struct {
    ID                string     `json:"id"`
    ShopID            string     `json:"shop_id"`
    EquipmentID       string     `json:"equipment_id"`
    ListID            string     `json:"list_id"`
    Description       string     `json:"description"`
    ServiceType       string     `json:"service_type"`
    CreatedBy         string     `json:"created_by"`
    CreatedByUsername string     `json:"created_by_username"`  // Dynamically populated from users table
    IsCompleted       bool       `json:"is_completed"`
    CreatedAt         time.Time  `json:"created_at"`
    UpdatedAt         time.Time  `json:"updated_at"`
    ServiceDate       *time.Time `json:"service_date"`
    ServiceHours      *int32     `json:"service_hours"`
}

type PaginatedEquipmentServicesResponse struct {
    Services   []EquipmentServiceResponse `json:"services"`
    TotalCount int64                      `json:"total_count"`
    HasMore    bool                       `json:"has_more"`
}

type CalendarServicesResponse struct {
    DateRange struct {
        StartDate time.Time `json:"start_date"`
        EndDate   time.Time `json:"end_date"`
    } `json:"date_range"`
    Services   []EquipmentServiceResponse `json:"services"`
    TotalCount int64                      `json:"total_count"`
}

type OverdueServiceResponse struct {
    EquipmentServiceResponse
    DaysOverdue int `json:"days_overdue"`
}

type DueSoonServiceResponse struct {
    EquipmentServiceResponse  
    DaysUntilDue int `json:"days_until_due"`
}

type OverdueServicesResponse struct {
    OverdueServices []OverdueServiceResponse `json:"overdue_services"`
    TotalCount      int64                    `json:"total_count"`
}

type DueSoonServicesResponse struct {
    DueSoonServices []DueSoonServiceResponse `json:"due_soon_services"`
    TotalCount      int64                    `json:"total_count"`
}
```

### 2. Repository Layer (`api/repository/equipment_services_repository.go`)

Following the existing repository pattern:

```go
type EquipmentServicesRepository interface {
    // CRUD Operations
    CreateEquipmentService(user *bootstrap.User, service model.EquipmentServices) (*model.EquipmentServices, error)
    GetEquipmentServiceByID(user *bootstrap.User, serviceID string) (*model.EquipmentServices, error)
    UpdateEquipmentService(user *bootstrap.User, service model.EquipmentServices) (*model.EquipmentServices, error)
    DeleteEquipmentService(user *bootstrap.User, serviceID string) error
    
    // Query Operations
    GetEquipmentServices(user *bootstrap.User, shopID string, filters GetEquipmentServicesRequest) ([]model.EquipmentServices, int64, error)
    GetServicesByEquipment(user *bootstrap.User, equipmentID string, limit, offset int, startDate, endDate *time.Time) ([]model.EquipmentServices, int64, error)
    GetServicesInDateRange(user *bootstrap.User, shopID string, startDate, endDate time.Time, equipmentID *string) ([]model.EquipmentServices, error)
    GetOverdueServices(user *bootstrap.User, shopID string, equipmentID *string, limit int) ([]OverdueServiceResponse, error)
    GetServicesDueSoon(user *bootstrap.User, shopID string, daysAhead int, equipmentID *string, limit int) ([]DueSoonServiceResponse, error)
    
    // Validation Helpers
    ValidateServiceOwnership(user *bootstrap.User, serviceID string) (bool, error)
    ValidateEquipmentAccess(user *bootstrap.User, equipmentID string) (string, error) // Returns shopID
    ValidateListAccess(user *bootstrap.User, listID string) (string, error)          // Returns shopID
    
    // Username Lookup
    GetUsernameByUserID(userID string) (string, error) // Dynamically fetch current username
}
```

### 3. Repository Implementation (`api/repository/equipment_services_repository_impl.go`)

Key implementation patterns following existing codebase:

```go
type EquipmentServicesRepositoryImpl struct {
    Db *sql.DB
}

func NewEquipmentServicesRepositoryImpl(db *sql.DB) *EquipmentServicesRepositoryImpl {
    return &EquipmentServicesRepositoryImpl{Db: db}
}

func (repo *EquipmentServicesRepositoryImpl) CreateEquipmentService(user *bootstrap.User, service model.EquipmentServices) (*model.EquipmentServices, error) {
    // Validate user has access to shop through equipment
    shopID, err := repo.ValidateEquipmentAccess(user, service.EquipmentID)
    if err != nil {
        return nil, fmt.Errorf("equipment access validation failed: %w", err)
    }
    
    // Validate list belongs to same shop
    listShopID, err := repo.ValidateListAccess(user, service.ListID)  
    if err != nil {
        return nil, fmt.Errorf("list access validation failed: %w", err)
    }
    
    if shopID != listShopID {
        return nil, errors.New("equipment and list must belong to the same shop")
    }
    
    // Use go-jet for type-safe insert
    stmt := EquipmentServices.INSERT(
        EquipmentServices.ID,
        EquipmentServices.ShopID,
        EquipmentServices.EquipmentID,
        EquipmentServices.ListID,
        EquipmentServices.Description,
        EquipmentServices.ServiceType,
        EquipmentServices.CreatedBy,
        EquipmentServices.IsCompleted,
        EquipmentServices.CreatedAt,
        EquipmentServices.UpdatedAt,
        EquipmentServices.ServiceDate,
        EquipmentServices.ServiceHours,
    ).MODEL(service).RETURNING(EquipmentServices.AllColumns)
    
    var createdService model.EquipmentServices
    err = stmt.Query(repo.Db, &createdService)
    if err != nil {
        return nil, fmt.Errorf("failed to create equipment service: %w", err)
    }
    
    slog.Info("Equipment service created", "service_id", service.ID, "created_by", user.UserID)
    return &createdService, nil
}

// GetUsernameByUserID dynamically fetches username from users table
func (repo *EquipmentServicesRepositoryImpl) GetUsernameByUserID(userID string) (string, error) {
    // Query users table for current username
    stmt := SELECT(Users.DisplayName).FROM(Users).WHERE(Users.ID.EQ(String(userID)))
    
    var username string
    err := stmt.Query(repo.Db, &username)
    if err != nil {
        slog.Warn("Failed to get username for user", "user_id", userID, "error", err)
        return "Unknown User", nil // Return fallback instead of error
    }
    
    if username == "" {
        return "Unknown User", nil
    }
    
    return username, nil
}

func (repo *EquipmentServicesRepositoryImpl) GetOverdueServices(user *bootstrap.User, shopID string, equipmentID *string, limit int) ([]OverdueServiceResponse, error) {
    // Build query with go-jet
    conditions := []postgres.BoolExpression{
        EquipmentServices.ShopID.EQ(String(shopID)),
        EquipmentServices.ServiceDate.IS_NOT_NULL(),
        EquipmentServices.ServiceDate.LT(NOW()),
    }
    
    if equipmentID != nil {
        conditions = append(conditions, EquipmentServices.EquipmentID.EQ(String(*equipmentID)))
    }
    
    stmt := SELECT(
        EquipmentServices.AllColumns,
        EXTRACT(DAY, NOW().SUB(EquipmentServices.ServiceDate)).AS("days_overdue"),
    ).FROM(
        EquipmentServices.
        INNER_JOIN(ShopMembers, ShopMembers.ShopID.EQ(EquipmentServices.ShopID)),
    ).WHERE(
        postgres.AND(conditions...).
        AND(ShopMembers.UserID.EQ(String(user.UserID))),
    ).ORDER_BY(EquipmentServices.ServiceDate.ASC()).
    LIMIT(int64(limit))
    
    var results []struct {
        model.EquipmentServices
        DaysOverdue int `sql:"days_overdue"`
    }
    
    err := stmt.Query(repo.Db, &results)
    if err != nil {
        return nil, fmt.Errorf("failed to get overdue services: %w", err)
    }
    
    overdueServices := make([]OverdueServiceResponse, len(results))
    for i, result := range results {
        // Get current username dynamically for each service
        username, err := repo.GetUsernameByUserID(result.CreatedBy)
        if err != nil {
            username = "Unknown User"
        }
        
        overdueServices[i] = OverdueServiceResponse{
            EquipmentServiceResponse: EquipmentServiceResponse{
                ID:                result.ID,
                ShopID:            result.ShopID,
                EquipmentID:       result.EquipmentID,
                ListID:            result.ListID,
                Description:       result.Description,
                ServiceType:       result.ServiceType,
                CreatedBy:         result.CreatedBy,
                CreatedByUsername: username, // Dynamically fetched
                IsCompleted:       result.IsCompleted,
                CreatedAt:         result.CreatedAt,
                UpdatedAt:         result.UpdatedAt,
                ServiceDate:       result.ServiceDate,
                ServiceHours:      result.ServiceHours,
            },
            DaysOverdue: result.DaysOverdue,
        }
    }
    
    return overdueServices, nil
}
```

### 4. Service Layer (`api/service/equipment_services_service.go`)

Interface following existing patterns:

```go
type EquipmentServicesService interface {
    // CRUD Operations
    CreateEquipmentService(user *bootstrap.User, request CreateEquipmentServiceRequest) (*EquipmentServiceResponse, error)
    GetEquipmentServiceByID(user *bootstrap.User, shopID, serviceID string) (*EquipmentServiceResponse, error)
    UpdateEquipmentService(user *bootstrap.User, shopID string, request UpdateEquipmentServiceRequest) (*EquipmentServiceResponse, error)
    DeleteEquipmentService(user *bootstrap.User, shopID, serviceID string) error
    
    // Query Operations
    GetEquipmentServices(user *bootstrap.User, shopID string, request GetEquipmentServicesRequest) (*PaginatedEquipmentServicesResponse, error)
    GetServicesByEquipment(user *bootstrap.User, equipmentID string, limit, offset int, startDate, endDate *time.Time) (*PaginatedEquipmentServicesResponse, error)
    GetServicesInDateRange(user *bootstrap.User, shopID string, request GetCalendarServicesRequest) (*CalendarServicesResponse, error)
    GetOverdueServices(user *bootstrap.User, shopID string, equipmentID *string, limit int) (*OverdueServicesResponse, error)
    GetServicesDueSoon(user *bootstrap.User, shopID string, request GetDueSoonServicesRequest) (*DueSoonServicesResponse, error)
}
```

### 5. Service Implementation (`api/service/equipment_services_service_impl.go`)

Key implementation with validation and business logic:

```go
type EquipmentServicesServiceImpl struct {
    EquipmentServicesRepository repository.EquipmentServicesRepository
    ShopsRepository             repository.ShopsRepository  // For membership validation
}

func NewEquipmentServicesServiceImpl(
    equipmentServicesRepo repository.EquipmentServicesRepository,
    shopsRepo repository.ShopsRepository,
) *EquipmentServicesServiceImpl {
    return &EquipmentServicesServiceImpl{
        EquipmentServicesRepository: equipmentServicesRepo,
        ShopsRepository:             shopsRepo,
    }
}

func (service *EquipmentServicesServiceImpl) CreateEquipmentService(user *bootstrap.User, request CreateEquipmentServiceRequest) (*EquipmentServiceResponse, error) {
    if user == nil {
        return nil, errors.New("unauthorized user")
    }
    
    // Validate service hours if provided (must be non-negative)
    if request.ServiceHours != nil && *request.ServiceHours < 0 {
        return nil, errors.New("service_hours must be non-negative")
    }
    
    // Service type is free-form text - no validation needed
    
    // Create service model
    service := model.EquipmentServices{
        ID:          uuid.New().String(),
        EquipmentID: request.EquipmentID,
        ListID:      request.ListID,
        Description: request.Description,
        ServiceType: request.ServiceType,
        CreatedBy:   user.UserID,
        IsCompleted: request.IsCompleted,
        CreatedAt:         time.Now(),
        UpdatedAt:         time.Now(),
        ServiceDate:       request.ServiceDate,
        ServiceHours:      request.ServiceHours,
    }
    
    createdService, err := service.EquipmentServicesRepository.CreateEquipmentService(user, service)
    if err != nil {
        slog.Error("Failed to create equipment service", "error", err, "user_id", user.UserID)
        return nil, fmt.Errorf("failed to create equipment service: %w", err)
    }
    
    // Get current username dynamically
    username, err := service.EquipmentServicesRepository.GetUsernameByUserID(createdService.CreatedBy)
    if err != nil {
        slog.Warn("Failed to get username, using fallback", "user_id", createdService.CreatedBy, "error", err)
        username = "Unknown User"
    }
    
    response := &EquipmentServiceResponse{
        ID:                createdService.ID,
        ShopID:            createdService.ShopID,
        EquipmentID:       createdService.EquipmentID,
        ListID:            createdService.ListID,
        Description:       createdService.Description,
        ServiceType:       createdService.ServiceType,
        CreatedBy:         createdService.CreatedBy,
        CreatedByUsername: username, // Dynamically fetched current username
        IsCompleted:       createdService.IsCompleted,
        CreatedAt:         createdService.CreatedAt,
        UpdatedAt:         createdService.UpdatedAt,
        ServiceDate:       createdService.ServiceDate,
        ServiceHours:      createdService.ServiceHours,
    }
    
    slog.Info("Equipment service created successfully", "service_id", createdService.ID, "user_id", user.UserID)
    return response, nil
}

func (service *EquipmentServicesServiceImpl) DeleteEquipmentService(user *bootstrap.User, shopID, serviceID string) error {
    if user == nil {
        return errors.New("unauthorized user")
    }
    
    // Check if user is shop member
    isMember, err := service.ShopsRepository.IsUserMemberOfShop(user, shopID)
    if err != nil {
        return fmt.Errorf("failed to verify shop membership: %w", err)
    }
    if !isMember {
        return errors.New("access denied: user is not a member of this shop")
    }
    
    // Check ownership or admin permissions
    canDelete, err := service.canUserDeleteService(user, shopID, serviceID)
    if err != nil {
        return fmt.Errorf("failed to verify delete permissions: %w", err)
    }
    if !canDelete {
        return errors.New("access denied: only service creators or shop admins can delete services")
    }
    
    err = service.EquipmentServicesRepository.DeleteEquipmentService(user, serviceID)
    if err != nil {
        slog.Error("Failed to delete equipment service", "error", err, "service_id", serviceID, "user_id", user.UserID)
        return fmt.Errorf("failed to delete equipment service: %w", err)
    }
    
    slog.Info("Equipment service deleted successfully", "service_id", serviceID, "user_id", user.UserID)
    return nil
}

// Helper method for permission checking
func (service *EquipmentServicesServiceImpl) canUserDeleteService(user *bootstrap.User, shopID, serviceID string) (bool, error) {
    // Check if user is shop admin
    isAdmin, err := service.ShopsRepository.IsUserShopAdmin(user, shopID)
    if err != nil {
        return false, err
    }
    if isAdmin {
        return true, nil
    }
    
    // Check if user owns the service
    ownsService, err := service.EquipmentServicesRepository.ValidateServiceOwnership(user, serviceID)
    if err != nil {
        return false, err
    }
    
    return ownsService, nil
}

// Service type validation removed - now free-form text
```

### 6. Controller Layer (`api/controller/equipment_services_controller.go`)

Following existing controller patterns:

```go
type EquipmentServicesController struct {
    EquipmentServicesService service.EquipmentServicesService
}

func NewEquipmentServicesController(equipmentServicesService service.EquipmentServicesService) *EquipmentServicesController {
    return &EquipmentServicesController{EquipmentServicesService: equipmentServicesService}
}

func (controller *EquipmentServicesController) CreateEquipmentService(c *gin.Context) {
    ctxUser, ok := c.Get("user")
    user, _ := ctxUser.(*bootstrap.User)
    
    if !ok {
        c.JSON(401, gin.H{"message": "unauthorized"})
        slog.Info("Unauthorized request")
        return
    }
    
    shopID := c.Param("shop_id")
    if shopID == "" {
        c.JSON(400, gin.H{"message": "shop_id is required"})
        return
    }
    
    var req request.CreateEquipmentServiceRequest
    if err := c.BindJSON(&req); err != nil {
        slog.Info("invalid request", "error", err)
        c.JSON(400, gin.H{"message": "invalid request", "details": err.Error()})
        return
    }
    
    createdService, err := controller.EquipmentServicesService.CreateEquipmentService(user, req)
    if err != nil {
        c.Error(err)
        return
    }
    
    c.JSON(201, response.StandardResponse{
        Status:  201,
        Message: "Equipment service created successfully",
        Data:    *createdService,
    })
}

func (controller *EquipmentServicesController) GetEquipmentServices(c *gin.Context) {
    ctxUser, ok := c.Get("user")
    user, _ := ctxUser.(*bootstrap.User)
    
    if !ok {
        c.JSON(401, gin.H{"message": "unauthorized"})
        slog.Info("Unauthorized request")
        return
    }
    
    shopID := c.Param("shop_id")
    if shopID == "" {
        c.JSON(400, gin.H{"message": "shop_id is required"})
        return
    }
    
    var req request.GetEquipmentServicesRequest
    if err := c.ShouldBindQuery(&req); err != nil {
        slog.Info("invalid query parameters", "error", err)
        c.JSON(400, gin.H{"message": "invalid query parameters", "details": err.Error()})
        return
    }
    
    services, err := controller.EquipmentServicesService.GetEquipmentServices(user, shopID, req)
    if err != nil {
        c.Error(err)
        return
    }
    
    c.JSON(200, response.StandardResponse{
        Status:  200,
        Message: "Services retrieved successfully",
        Data:    *services,
    })
}

func (controller *EquipmentServicesController) DeleteEquipmentService(c *gin.Context) {
    ctxUser, ok := c.Get("user")
    user, _ := ctxUser.(*bootstrap.User)
    
    if !ok {
        c.JSON(401, gin.H{"message": "unauthorized"})
        slog.Info("Unauthorized request")
        return
    }
    
    shopID := c.Param("shop_id")
    serviceID := c.Param("service_id")
    
    if shopID == "" {
        c.JSON(400, gin.H{"message": "shop_id is required"})
        return
    }
    
    if serviceID == "" {
        c.JSON(400, gin.H{"message": "service_id is required"})
        return
    }
    
    err := controller.EquipmentServicesService.DeleteEquipmentService(user, shopID, serviceID)
    if err != nil {
        c.Error(err)
        return
    }
    
    c.JSON(200, gin.H{"message": "Equipment service deleted successfully"})
}
```

### 7. Routes Configuration (`api/route/equipment_services_route.go`)

Following existing route patterns:

```go
func NewEquipmentServicesRouter(db *sql.DB, env *bootstrap.Env, group *gin.RouterGroup) {
    equipmentServicesRepository := repository.NewEquipmentServicesRepositoryImpl(db)
    shopsRepository := repository.NewShopsRepositoryImpl(db)
    
    controller := &controller.EquipmentServicesController{
        EquipmentServicesService: service.NewEquipmentServicesServiceImpl(equipmentServicesRepository, shopsRepository),
    }
    
    // Equipment Service CRUD Operations
    group.POST("/shops/:shop_id/equipment-services", controller.CreateEquipmentService)
    group.GET("/shops/:shop_id/equipment-services", controller.GetEquipmentServices) 
    group.GET("/shops/:shop_id/equipment-services/:service_id", controller.GetEquipmentServiceByID)
    group.PUT("/shops/:shop_id/equipment-services/:service_id", controller.UpdateEquipmentService)
    group.DELETE("/shops/:shop_id/equipment-services/:service_id", controller.DeleteEquipmentService)
    
    // Equipment-specific Services
    group.GET("/shops/:shop_id/equipment/:equipment_id/services", controller.GetServicesByEquipment)
    
    // Calendar and Status Operations
    group.GET("/shops/:shop_id/equipment-services/calendar", controller.GetServicesInDateRange)
    group.GET("/shops/:shop_id/equipment-services/overdue", controller.GetOverdueServices)
    group.GET("/shops/:shop_id/equipment-services/due-soon", controller.GetServicesDueSoon)
}
```

## Security and Authorization

### Permission Matrix

| Operation | Shop Member | Shop Admin | Service Creator | Notes |
|-----------|-------------|------------|-----------------|-------|
| View Services | ✓ | ✓ | ✓ | Can view all services in shops they're members of |
| Create Service | ✓ | ✓ | ✓ | Must reference valid equipment and list in same shop |
| Edit Own Service | ✓ | ✓ | ✓ | Can edit services they created |
| Edit Others' Service | ✗ | ✓ | ✗ | Only admins can edit others' services |
| Delete Own Service | ✓ | ✓ | ✓ | Can delete services they created |
| Delete Others' Service | ✗ | ✓ | ✗ | Only admins can delete others' services |

### Authorization Implementation

```go
func (service *EquipmentServicesServiceImpl) validateUserCanModifyService(user *bootstrap.User, serviceID string) error {
    // Get service to check shop and ownership
    service, err := service.EquipmentServicesRepository.GetEquipmentServiceByID(user, serviceID)
    if err != nil {
        return fmt.Errorf("service not found or access denied: %w", err)
    }
    
    // Check if user is member of the shop
    isMember, err := service.ShopsRepository.IsUserMemberOfShop(user, service.ShopID)
    if err != nil || !isMember {
        return errors.New("access denied: user is not a member of this shop")
    }
    
    // Check if user owns the service
    if service.CreatedBy == user.UserID {
        return nil
    }
    
    // Check if user is shop admin
    isAdmin, err := service.ShopsRepository.IsUserShopAdmin(user, service.ShopID)
    if err != nil {
        return fmt.Errorf("failed to verify admin status: %w", err)
    }
    
    if !isAdmin {
        return errors.New("access denied: only service creators or shop admins can modify services")
    }
    
    return nil
}
```

## Error Handling

### Error Response Format

Following existing patterns:

```go
type EquipmentServiceError struct {
    Code    string                 `json:"code"`
    Message string                 `json:"message"`
    Details map[string]interface{} `json:"details,omitempty"`
}

type ErrorResponse struct {
    Success bool                   `json:"success"`
    Error   EquipmentServiceError `json:"error"`
}
```

### Common Error Codes

- `SHOP_NOT_FOUND`: Shop doesn't exist or user has no access
- `SERVICE_NOT_FOUND`: Service doesn't exist or user has no access
- `EQUIPMENT_NOT_FOUND`: Equipment doesn't exist or not in user's shop
- `LIST_NOT_FOUND`: List doesn't exist or not in user's shop
- `INSUFFICIENT_PERMISSIONS`: User lacks required permissions
- `INVALID_INPUT`: Input validation failed
- `INVALID_SERVICE_TYPE`: Service type not in allowed values
- `INVALID_DATE_RANGE`: Date range parameters are invalid
- `EQUIPMENT_LIST_MISMATCH`: Equipment and list belong to different shops

### Error Handling in Controllers

```go
func handleEquipmentServiceError(c *gin.Context, err error) {
    var statusCode int
    var errorCode string
    
    switch {
    case strings.Contains(err.Error(), "not found"):
        statusCode = 404
        errorCode = "RESOURCE_NOT_FOUND"
    case strings.Contains(err.Error(), "access denied"):
        statusCode = 403
        errorCode = "INSUFFICIENT_PERMISSIONS"
    case strings.Contains(err.Error(), "invalid"):
        statusCode = 400
        errorCode = "INVALID_INPUT"
    case strings.Contains(err.Error(), "unauthorized"):
        statusCode = 401
        errorCode = "UNAUTHORIZED"
    default:
        statusCode = 500
        errorCode = "INTERNAL_ERROR"
    }
    
    c.JSON(statusCode, ErrorResponse{
        Success: false,
        Error: EquipmentServiceError{
            Code:    errorCode,
            Message: err.Error(),
        },
    })
}
```

## Performance Considerations

### Database Indexing Strategy

Based on the mobile app's query patterns:

1. **Primary Indexes** (already defined in schema):
   - `shop_id` - for shop-wide queries
   - `equipment_id` - for equipment-specific queries
   - `service_date` - for calendar and overdue queries
   - `created_by` - for user-specific queries

2. **Composite Indexes**:
   - `(shop_id, service_date)` - for shop calendar queries
   - `(equipment_id, service_date)` - for equipment service history
   - `(shop_id, type)` - for filtering by service type
   - `(created_by, created_at)` - for user service history

### Query Optimization

```go
// Efficient overdue services query
func (repo *EquipmentServicesRepositoryImpl) GetOverdueServices(user *bootstrap.User, shopID string, equipmentID *string, limit int) ([]OverdueServiceResponse, error) {
    baseQuery := SELECT(
        EquipmentServices.AllColumns,
        EXTRACT(DAY, NOW().SUB(EquipmentServices.ServiceDate)).AS("days_overdue"),
    ).FROM(
        EquipmentServices.
        INNER_JOIN(ShopMembers, ShopMembers.ShopID.EQ(EquipmentServices.ShopID)),
    )
    
    conditions := []postgres.BoolExpression{
        EquipmentServices.ShopID.EQ(String(shopID)),
        EquipmentServices.ServiceDate.IS_NOT_NULL(),
        EquipmentServices.ServiceDate.LT(NOW()),
        ShopMembers.UserID.EQ(String(user.UserID)),
    }
    
    if equipmentID != nil {
        conditions = append(conditions, EquipmentServices.EquipmentID.EQ(String(*equipmentID)))
    }
    
    stmt := baseQuery.WHERE(postgres.AND(conditions...)).
        ORDER_BY(EquipmentServices.ServiceDate.ASC()).
        LIMIT(int64(limit))
    
    // This will use indexes efficiently:
    // - shop_id index for initial filtering
    // - service_date index for temporal filtering
    // - equipment_id index if specified
    
    var results []struct {
        model.EquipmentServices
        DaysOverdue int `sql:"days_overdue"`
    }
    
    return stmt.Query(repo.Db, &results)
}
```

### Pagination Strategy

```go
func (repo *EquipmentServicesRepositoryImpl) GetEquipmentServices(user *bootstrap.User, shopID string, filters GetEquipmentServicesRequest) ([]model.EquipmentServices, int64, error) {
    // Build conditions based on filters
    conditions := buildFilterConditions(shopID, filters)
    
    // Count query for pagination
    countStmt := SELECT(COUNT(Star)).FROM(
        EquipmentServices.
        INNER_JOIN(ShopMembers, ShopMembers.ShopID.EQ(EquipmentServices.ShopID)),
    ).WHERE(
        postgres.AND(conditions...).
        AND(ShopMembers.UserID.EQ(String(user.UserID))),
    )
    
    var totalCount int64
    err := countStmt.Query(repo.Db, &totalCount)
    if err != nil {
        return nil, 0, fmt.Errorf("failed to count services: %w", err)
    }
    
    // Data query with pagination
    dataStmt := SELECT(EquipmentServices.AllColumns).FROM(
        EquipmentServices.
        INNER_JOIN(ShopMembers, ShopMembers.ShopID.EQ(EquipmentServices.ShopID)),
    ).WHERE(
        postgres.AND(conditions...).
        AND(ShopMembers.UserID.EQ(String(user.UserID))),
    ).ORDER_BY(EquipmentServices.CreatedAt.DESC()).
    LIMIT(int64(filters.Limit)).
    OFFSET(int64(filters.Offset))
    
    var services []model.EquipmentServices
    err = dataStmt.Query(repo.Db, &services)
    if err != nil {
        return nil, 0, fmt.Errorf("failed to get services: %w", err)
    }
    
    return services, totalCount, nil
}
```

## Integration with Main Application

### 1. Database Migration

Create migration file `migrations/002_create_equipment_services_table.sql`:

```sql
-- Add equipment_services table
CREATE TABLE equipment_services (
    id VARCHAR(36) PRIMARY KEY,
    shop_id VARCHAR(36) NOT NULL,
    equipment_id VARCHAR(36) NOT NULL,
    list_id VARCHAR(36) NOT NULL,
    description TEXT NOT NULL,
    service_type TEXT NOT NULL,
    created_by VARCHAR(36) NOT NULL,
    is_completed BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    service_date TIMESTAMP NULL,
    service_hours INTEGER NULL,
    
    CONSTRAINT fk_equipment_services_shop 
        FOREIGN KEY (shop_id) REFERENCES shops(id) ON DELETE CASCADE,
    CONSTRAINT fk_equipment_services_equipment 
        FOREIGN KEY (equipment_id) REFERENCES shop_vehicle(id) ON DELETE CASCADE,
    CONSTRAINT fk_equipment_services_list 
        FOREIGN KEY (list_id) REFERENCES shop_lists(id) ON DELETE CASCADE,
    CONSTRAINT chk_service_hours_non_negative 
        CHECK (service_hours IS NULL OR service_hours >= 0)
);

-- Create indexes
CREATE INDEX idx_equipment_services_shop_id ON equipment_services(shop_id);
CREATE INDEX idx_equipment_services_equipment_id ON equipment_services(equipment_id);
CREATE INDEX idx_equipment_services_service_date ON equipment_services(service_date);
CREATE INDEX idx_equipment_services_created_by ON equipment_services(created_by);
CREATE INDEX idx_equipment_services_service_type ON equipment_services(service_type);
CREATE INDEX idx_equipment_services_is_completed ON equipment_services(is_completed);
CREATE INDEX idx_equipment_services_shop_date ON equipment_services(shop_id, service_date);
CREATE INDEX idx_equipment_services_equipment_date ON equipment_services(equipment_id, service_date);
CREATE INDEX idx_equipment_services_shop_completed ON equipment_services(shop_id, is_completed);
```

### 2. Route Registration

In `api/route/route.go`, add equipment services routes:

```go
func NewRouter(db *sql.DB, env *bootstrap.Env) *gin.Engine {
    // ... existing setup ...
    
    v1 := router.Group("/api/v1")
    v1.Use(middleware.AuthenticationMiddleware(authClient))
    
    // ... existing routes ...
    
    // Equipment Services Routes
    NewEquipmentServicesRouter(db, env, v1)
    
    return router
}
```

### 3. Go-Jet Model Generation

After running the migration, regenerate Go-Jet models:

```bash
# This will generate the EquipmentServices model and table definitions
jet -dsn=postgresql://user:pass@localhost/db -path=./.gen
```

## Testing Strategy

### 1. Unit Tests

```go
func TestEquipmentServicesService_CreateEquipmentService(t *testing.T) {
    tests := []struct {
        name          string
        user          *bootstrap.User
        request       CreateEquipmentServiceRequest
        mockSetup     func(*mocks.MockEquipmentServicesRepository, *mocks.MockShopsRepository)
        expectedError string
    }{
        {
            name: "successful creation",
            user: &bootstrap.User{UserID: "user1", Username: "testuser"},
            request: CreateEquipmentServiceRequest{
                EquipmentID: "equip1",
                ListID:      "list1", 
                Description: "Oil change",
                Type:        "maintenance",
            },
            mockSetup: func(equipRepo *mocks.MockEquipmentServicesRepository, shopsRepo *mocks.MockShopsRepository) {
                equipRepo.EXPECT().CreateEquipmentService(gomock.Any(), gomock.Any()).Return(&model.EquipmentServices{
                    ID:          "service1",
                    ShopID:      "shop1",
                    EquipmentID: "equip1",
                    ListID:      "list1",
                    Description: "Oil change",
                    Type:        "maintenance",
                }, nil)
            },
            expectedError: "",
        },
        {
            name: "unauthorized user",
            user: nil,
            request: CreateEquipmentServiceRequest{},
            mockSetup: func(*mocks.MockEquipmentServicesRepository, *mocks.MockShopsRepository) {},
            expectedError: "unauthorized user",
        },
        {
            name: "invalid service type", 
            user: &bootstrap.User{UserID: "user1", Username: "testuser"},
            request: CreateEquipmentServiceRequest{
                EquipmentID: "equip1",
                ListID:      "list1",
                Description: "Oil change", 
                Type:        "invalid_type",
            },
            mockSetup: func(*mocks.MockEquipmentServicesRepository, *mocks.MockShopsRepository) {},
            expectedError: "invalid service type",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            ctrl := gomock.NewController(t)
            defer ctrl.Finish()
            
            equipRepo := mocks.NewMockEquipmentServicesRepository(ctrl)
            shopsRepo := mocks.NewMockShopsRepository(ctrl)
            tt.mockSetup(equipRepo, shopsRepo)
            
            service := service.NewEquipmentServicesServiceImpl(equipRepo, shopsRepo)
            
            result, err := service.CreateEquipmentService(tt.user, tt.request)
            
            if tt.expectedError != "" {
                assert.Error(t, err)
                assert.Contains(t, err.Error(), tt.expectedError)
                assert.Nil(t, result)
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, result)
                assert.Equal(t, "service1", result.ID)
            }
        })
    }
}
```

### 2. Integration Tests

```go
func TestEquipmentServicesAPI_Integration(t *testing.T) {
    // Setup test database
    db := setupTestDB(t)
    defer cleanupTestDB(db)
    
    // Setup test data
    user := setupTestUser(t, db)
    shop := setupTestShop(t, db, user.UserID)
    equipment := setupTestEquipment(t, db, shop.ID, user.UserID)
    list := setupTestList(t, db, shop.ID, user.UserID)
    
    // Setup router
    router := setupTestRouter(db)
    
    // Test create equipment service
    createReq := CreateEquipmentServiceRequest{
        EquipmentID: equipment.ID,
        ListID:      list.ID,
        Description: "Regular maintenance check",
        Type:        "maintenance",
        ServiceDate: &time.Now().Add(24 * time.Hour),
        ServiceHours: &[]int32{1000}[0],
    }
    
    body, _ := json.Marshal(createReq)
    req := httptest.NewRequest("POST", fmt.Sprintf("/api/v1/shops/%s/equipment-services", shop.ID), bytes.NewBuffer(body))
    req.Header.Set("Authorization", "Bearer "+user.Token)
    req.Header.Set("Content-Type", "application/json")
    
    w := httptest.NewRecorder()
    router.ServeHTTP(w, req)
    
    assert.Equal(t, 201, w.Code)
    
    var response response.StandardResponse
    err := json.Unmarshal(w.Body.Bytes(), &response)
    assert.NoError(t, err)
    assert.Equal(t, 201, response.Status)
    assert.Equal(t, "Equipment service created successfully", response.Message)
    
    // Test get equipment services
    req = httptest.NewRequest("GET", fmt.Sprintf("/api/v1/shops/%s/equipment-services", shop.ID), nil)
    req.Header.Set("Authorization", "Bearer "+user.Token)
    
    w = httptest.NewRecorder()
    router.ServeHTTP(w, req)
    
    assert.Equal(t, 200, w.Code)
    
    // Verify response contains the created service
    err = json.Unmarshal(w.Body.Bytes(), &response)
    assert.NoError(t, err)
    assert.Equal(t, 200, response.Status)
    
    data, ok := response.Data.(map[string]interface{})
    assert.True(t, ok)
    
    services, ok := data["services"].([]interface{})
    assert.True(t, ok)
    assert.Len(t, services, 1)
}
```

## Questions for Clarification

Based on my analysis of the mobile specification and current server architecture, I have the following questions:

### 1. Service Type Validation
The mobile spec mentions service types like "maintenance, repair, etc." but doesn't provide the complete list. Should we:
- Use a predefined enum of service types?
- Allow free-form text for service types?
- Make service types configurable per shop?

**Recommendation**: Start with predefined types `["maintenance", "repair", "inspection", "upgrade", "other"]` but make it easily extensible.

### 2. Service Date Flexibility
The mobile spec allows service dates to be past, present, or future. Should we:
- Add a "completed" boolean field to distinguish scheduled vs completed services?
- Use service_date in the past to indicate completion?
- Add separate scheduled_date and completed_date fields?

**Recommendation**: Keep it simple with just service_date and infer completion status from the date being in the past.

### 3. Username Denormalization
The mobile spec includes `created_by_username` for display purposes. Should we:
- Store the username at service creation time (current approach)?
- Look up usernames dynamically (slower but always current)?
- Update usernames when users change their display names?

**Recommendation**: Store at creation time for performance, but consider adding a background job to update if username changes are common.

### 4. Service Hours Validation
The spec includes service_hours as an integer. Should we:
- Validate that service hours are reasonable (not negative, not impossibly high)?
- Allow different units (hours vs miles/kilometers)?
- Make it optional always?

**Recommendation**: Make it optional, validate >= 0 if provided, assume hours as the unit.

### 5. Pagination Limits
The mobile spec suggests different default limits for different endpoints. Should we:
- Use consistent pagination across all endpoints?
- Allow different defaults per endpoint type?
- Make pagination limits configurable?

**Recommendation**: Use consistent defaults but allow per-endpoint overrides where it makes sense.

### 6. Rate Limiting
Per clarification, no rate limiting will be implemented at this time for equipment services endpoints.

## Implementation Timeline

### Phase 1: Core CRUD Operations (Week 1)
1. Database migration and model generation
2. Repository layer implementation
3. Service layer with basic CRUD
4. Controller layer with authentication
5. Route registration
6. Basic unit tests

### Phase 2: Advanced Queries (Week 2)
1. Calendar view functionality
2. Overdue services detection
3. Due soon services
4. Equipment-specific service history
5. Filtering and pagination
6. Integration tests

### Phase 3: Performance and Polish (Week 3)
1. Database index optimization
2. Query performance testing
3. Error handling refinement
4. Comprehensive test coverage
5. Documentation updates
6. Security audit

### Phase 4: Deployment and Monitoring (Week 4)
1. Staging environment deployment
2. Load testing
3. Monitoring and alerting setup
4. Production deployment
5. Mobile app integration testing
6. User acceptance testing

## Conclusion

This implementation design follows the established patterns in the codebase while providing all the functionality specified in the mobile application's API design document. The modular architecture ensures maintainability, the security model protects user data, and the performance optimizations handle expected load patterns.

The design prioritizes:
1. **Consistency** with existing codebase patterns
2. **Security** with proper authentication and authorization
3. **Performance** with efficient database queries and indexing
4. **Maintainability** with clean separation of concerns
5. **Testability** with comprehensive unit and integration tests

The implementation will provide a solid foundation for the equipment services feature while maintaining the high quality and reliability standards of the existing system.